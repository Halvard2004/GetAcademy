<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Basic Platformer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #333;
    }
    canvas {
      background: #222;
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    // Get the canvas and its context
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // Track keyboard input
    const keys = {};
    window.addEventListener("keydown", (e) => { keys[e.key] = true; });
    window.addEventListener("keyup", (e) => { keys[e.key] = false; });

    // Gravity and friction constants
    const gravity = 0.8;
    const friction = 0.9;

    // Player class
    class Player {
      constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.velX = 0;
        this.velY = 0;
        this.speed = 5;
        this.jumping = false;
      }
      
      update() {
        // Horizontal movement
        if (keys["ArrowRight"] || keys["d"]) {
          if (this.velX < this.speed) { this.velX++; }
        }
        if (keys["ArrowLeft"] || keys["a"]) {
          if (this.velX > -this.speed) { this.velX--; }
        }
        // Jumping
        if ((keys["ArrowUp"] || keys["w"] || keys[" "]) && !this.jumping) {
          this.jumping = true;
          this.velY = -15;
        }
        
        // Apply gravity
        this.velY += gravity;
        
        // Apply friction (simple horizontal slowing)
        this.velX *= friction;
        
        // Update position
        this.x += this.velX;
        this.y += this.velY;
        
        // Prevent player from going off the canvas
        if (this.x < 0) { 
          this.x = 0; 
          this.velX = 0; 
        }
        if (this.x + this.width > canvas.width) { 
          this.x = canvas.width - this.width; 
          this.velX = 0; 
        }
        // If player touches the "ground" (bottom of canvas)
        if (this.y + this.height > canvas.height) {
          this.y = canvas.height - this.height;
          this.jumping = false;
          this.velY = 0;
        }
      }
      
      draw() {
        ctx.fillStyle = "#f00";
        ctx.fillRect(this.x, this.y, this.width, this.height);
      }
    }

    // Platform class
    class Platform {
      constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
      }
      
      draw() {
        ctx.fillStyle = "#0f0";
        ctx.fillRect(this.x, this.y, this.width, this.height);
      }
    }

    // Create the player and some platforms
    const player = new Player(50, canvas.height - 60, 50, 50);
    const platforms = [
      new Platform(100, 500, 200, 20),
      new Platform(400, 400, 200, 20),
      new Platform(200, 300, 200, 20)
    ];

    // Simple Axis-Aligned Bounding Box (AABB) collision detection
    function collisionCheck(player, plat) {
      return (
        player.x < plat.x + plat.width &&
        player.x + player.width > plat.x &&
        player.y < plat.y + plat.height &&
        player.y + player.height > plat.y
      );
    }

    // Check and resolve collisions with platforms
    function resolveCollisions() {
      platforms.forEach(plat => {
        if (collisionCheck(player, plat)) {
          // Assume the collision is from above for this basic example
          if (player.velY > 0) {
            player.y = plat.y - player.height;
            player.velY = 0;
            player.jumping = false;
          }
        }
      });
    }

    // Main game loop
    function gameLoop() {
      // Clear the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Update and draw the player
      player.update();
      resolveCollisions();
      player.draw();
      
      // Draw each platform
      platforms.forEach(plat => {
        plat.draw();
      });
      
      // Request the next animation frame
      requestAnimationFrame(gameLoop);
    }

    // Start the game loop
    gameLoop();
  </script>
</body>
</html>